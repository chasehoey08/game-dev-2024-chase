



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0093E9 0%, #80D0C7 100%);
        }
        canvas {
            background-color: #333;
            display: block;
            border: 5px solid #111;
            box-shadow: 0px 0px 10px #000;
            border-radius: 10px;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    if (!ctx) {
        alert("Canvas or context is not available!");
    }

    // Game variables
    let gravity = 0.5;
    let score = 0;
    let player, platforms, coins, enemies, particles;

    // Initialize or reset game state
    function initGame() {
        player = {
            x: 50, y: 500, width: 40, height: 40, color: '#FFDD44',
            dx: 0, dy: 0, speed: 5, jumping: false, fallingThrough: false
        };
        particles = [];
        platforms = [
            { x: 150, y: 400, width: 200, height: 20, color: '#FF5733' },
            { x: 450, y: 300, width: 200, height: 20, color: '#FF5733' },
            { x: 300, y: 200, width: 200, height: 20, color: '#FF5733' },
            { x: 100, y: 500, width: 200, height: 20, color: '#FF5733' },
        ];
        coins = [];
        enemies = [];

        // Initialize coins and enemies randomly
        for (let i = 0; i < 5; i++) {
            coins.push({ x: getRandomInt(100, 700), y: getRandomInt(50, 550), radius: 10, color: '#FFD700' });
        }
        for (let i = 0; i < 3; i++) {
            enemies.push({ x: getRandomInt(100, 700), y: getRandomInt(50, 550), width: 30, height: 30, speed: 2, color: '#FF0000' });
        }
    }

    // Utility function to get random integer between min and max
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    // Handle player movement
    window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') player.dx = -player.speed;
        if (e.key === 'ArrowRight') player.dx = player.speed;
        if (e.key === 'ArrowUp' && !player.jumping) {  // Jump with Up Arrow
            player.dy = -10;
            player.jumping = true;
        }
        if (e.key === 'ArrowDown') {  // Enable falling through platforms
            player.fallingThrough = true;
        }
    });
    window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') player.dx = 0;
        if (e.key === 'ArrowDown') {  // Disable falling through once down arrow is released
            player.fallingThrough = false;
        }
    });

    // Collision detection
    function isColliding(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
    }

    function update() {
        // Player physics
        player.dy += gravity;
        player.x += player.dx;
        player.y += player.dy;

        // Screen boundaries
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
        if (player.y + player.height > canvas.height) {
            player.y = canvas.height - player.height;
            player.jumping = false;
            player.dy = 0;
        }

        // Platform collision
        platforms.forEach(platform => {
            if (!player.fallingThrough &&
                isColliding(player, { ...platform, y: platform.y - 5 }) && 
                player.dy > 0) {
                player.y = platform.y - player.height;
                player.dy = 0;
                player.jumping = false;
            }
        });

        // Update particles
        particles = particles.filter(p => {
            p.x += p.dx;
            p.y += p.dy;
            p.alpha -= 0.01;
            return p.alpha > 0;
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw background gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "#88CCFF");
        gradient.addColorStop(1, "#003366");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw platforms with cell shading
        platforms.forEach(platform => {
            ctx.fillStyle = platform.color;
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
        });

        // Draw player with cell shading
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;
        ctx.strokeRect(player.x, player.y, player.width, player.height);

        // Draw particles
        particles.forEach(p => {
            ctx.fillStyle = `rgba(255, 215, 0, ${p.alpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw score
        ctx.fillStyle = 'black';
        ctx.font = '20px Arial';
        ctx.fillText('Score: ' + score, 10, 20);
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    initGame();  // Start the game initially
    gameLoop();  // Begin the game loop
</script>
</body>
</html>
