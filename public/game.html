



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #87CEEB; /* Sky blue background */
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #3498db;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25);
            padding: 10px;
        }
        #gameCanvas {
            background-color: #3498db; /* Blue background */
            border: 2px solid #333;
            border-radius: 10px;
        }
    </style>
</head>
<body>

<div class="game-container">
    <canvas id="gameCanvas" width="800" height="400"></canvas>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game settings
    const gravity = 0.5;
    const jumpPower = -10;
    let isJumping = false;
    let gameSpeed = 3;
    let score = 0;
    let particles = [];
    let gameOver = false;

    // Cube character settings
    const cube = {
        x: 50,
        y: canvas.height - 60,
        width: 30,
        height: 30,
        color: "#2ecc71", // Green
        dy: 0
    };

    // Spike obstacle settings
    const spikes = [];
    const spikeWidth = 20;
    const spikeHeight = 30;
    const spikeGap = 300;

    function addSpike() {
        const spikeX = canvas.width + Math.random() * 100;
        spikes.push({ x: spikeX, y: canvas.height - spikeHeight });
    }

    function updateSpikes() {
        for (let i = spikes.length - 1; i >= 0; i--) {
            spikes[i].x -= gameSpeed;

            // Remove off-screen spikes and add a new one
            if (spikes[i].x + spikeWidth < 0) {
                spikes.splice(i, 1);
                score++;
                if (score % 5 === 0) gameSpeed += 0.5; // Increase speed every 5 points
                addSpike();
            }
        }
    }

    function drawCube() {
        // Cell-shaded effect
        ctx.fillStyle = cube.color;
        ctx.fillRect(cube.x, cube.y, cube.width, cube.height);
        ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
        ctx.lineWidth = 3;
        ctx.strokeRect(cube.x, cube.y, cube.width, cube.height);
    }

    function drawSpikes() {
        ctx.fillStyle = "#e74c3c"; // Red for spikes
        for (const spike of spikes) {
            ctx.beginPath();
            ctx.moveTo(spike.x, spike.y);
            ctx.lineTo(spike.x + spikeWidth / 2, spike.y - spikeHeight);
            ctx.lineTo(spike.x + spikeWidth, spike.y);
            ctx.closePath();
            ctx.fill();
            // Cell-shaded outline
            ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    function handleJump() {
        if (!isJumping && cube.y + cube.height >= canvas.height - 10) {
            isJumping = true;
            cube.dy = jumpPower;
        }
    }

    function updateCube() {
        // Apply gravity and jump
        cube.dy += gravity;
        cube.y += cube.dy;

        // Stop jumping when landing
        if (cube.y + cube.height > canvas.height) {
            cube.y = canvas.height - cube.height;
            isJumping = false;
        }
    }

    function detectCollision() {
        for (const spike of spikes) {
            if (
                cube.x < spike.x + spikeWidth &&
                cube.x + cube.width > spike.x &&
                cube.y + cube.height > spike.y
            ) {
                triggerGameOver();
            }
        }
    }

    function triggerGameOver() {
        gameOver = true;
        for (let i = 0; i < 20; i++) {
            createParticle(cube.x + cube.width / 2, cube.y + cube.height / 2);
        }
        setTimeout(() => alert("Game Over! Score: " + score), 100);
        setTimeout(() => document.location.reload(), 1000);
    }

    function createParticle(x, y) {
        particles.push({
            x: x,
            y: y,
            dx: (Math.random() - 0.5) * 4,
            dy: (Math.random() - 0.5) * 4,
            size: Math.random() * 4 + 2,
            color: "#e74c3c",
            life: 60
        });
    }

    function updateParticles() {
        particles = particles.filter(p => p.life > 0);
        for (const particle of particles) {
            particle.x += particle.dx;
            particle.y += particle.dy;
            particle.life -= 1;
        }
    }

    function drawParticles() {
        for (const particle of particles) {
            ctx.fillStyle = particle.color;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!gameOver) {
            updateCube();
            updateSpikes();
            detectCollision();
        }
        updateParticles();

        drawCube();
        drawSpikes();
        drawParticles();

        requestAnimationFrame(gameLoop);
    }

    // Initialize spikes
    for (let i = 0; i < 3; i++) {
        addSpike();
    }

    // Event listener for jumping
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !gameOver) {
            handleJump();
        }
    });

    gameLoop();
</script>

</body>
</html>
